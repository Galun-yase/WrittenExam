=================================================
				===集合===
=================================================
一、Map集合
	-HashMap
		1、底层数据结构 (jdk8)数组+链表+红黑树
		2、数组长度为2的整数次幂，初始容量为16负载因子为0.75，重载方法tableSizefor(n)会返回一个大于等于n的最近的2的整数次幂
		  使用位运算更快，且2的整数次幂可以保证取到数组的每一位
		3、负载因子1会产生更大的哈希碰撞，0.5会浪费空间
		4、链表长度大于8(且散列表容量大于64)->红黑树，小于6->链表 (①泊松分布 超过8个很低概率 ②平均查找长度log8=3|8/2=4才有必要转换)
		5、添加put(k,v)->putVal(hash,k,v)
				  (1)table为空，则resize()初始化散列表
				  (2)table[i]不存在节点没发生碰撞则newNode
				  (3)否则
					(1)节点相同即覆盖
					(2)节点为红黑树节点，则添加树节点
					(3)否则为链表，找到最后一个节点插入(有相同即覆盖)
		6  jdk7transfer头插法->死循环、数据丢失
		   jdk8resize尾插法解决了jdk7的问题 | 但是putVal会导致数据覆盖
		7、key与value都可以为null
	-HashTable 同步,初始化11,2n+1扩容
	-LinkedHashMap 继承hashmap 双向链表维护插入顺序(还有访问顺序LRU，需要扩展不然get会报修改异常)
	-TreeMap  红黑树、自然序(传入比较器) value可以为null

二、List集合
	-ArrayList
		1、指定容量|无参为0
		2、add(E e) ①检测是否扩容②赋值
			ensureCapacityInternal->ensureExplicitCapacity->grow 扩容1.5倍 为空则直接扩到10再扩1.5倍 
			拷贝copyof调用底层System.arraycopy 更快
		3、基于动态数组，增删时先拷贝数组
	-Vector 同步、扩展2倍的ArrayList	
	-LinkedList 双向链表，用作栈队列
三、Set集合
	-HashSet           hashmap
	-LinkedHashSet     linkedhashmap
	-TreeSet           treemap

AVL(平衡二叉树)、红黑树(插入保证平衡)、B树、B+树、Trie树(字典树-排序字符串)
AVL树: 带平衡条件的二叉查找树，通过平衡因子差值判断是否平衡，通过旋转实现平衡；
       所有节点的左右两个子树的高度差的绝对值不超过1，严格平衡二叉树，
       平衡度高，调整频率高，适合查询多
红黑树: 确保从根到叶子结点的路径中没有相差两倍的二叉查找树
       平衡度低，调整频率低，适合增删多


=================================================
				===网络===
=================================================

一、概述
	1.实现主机连通 电路交换-报文交换-分组交换
	2.带宽 时延(发送、传播、处理、排队)
	3.体系结构 7层 4层 -> 5层(4个首部，一个尾部) 服务垂直，协议水平
	物理层-数据链路层-网络层-传输层-(会话层-表示层)-应用层
二、物理层
	1.物理层屏蔽掉传输媒体和通信手段的差异
	2.信道复用技术     CDMA码分复用(码片|内积)
	3.数字传输系统技术
	4.宽带接入技术      有线、无线|数字技术、光纤
	5.网络互联设备(拓展网络) 中继器、集线器
三、数据链路层
	1.网卡-帧
	2.描述局域网
	3.使用的信道-点对点信道 封装成帧-透明传输-差错检验 PPP协议(LCP测试链路、NCP选择网络协议)建立串行链路
	4.        -广播信道 局域网采用以太网协议-> CSMA/CD载波监听多点接入/碰撞检测 MAC地址(网卡全球唯一)
	5.扩展以太网(局域网) 网桥、交换机
四、网络层
	1.不采用虚电路，采用只提供简单灵活的、无连接的、尽最大努力交付的数据报服务
	2.IP地址 ARP/RARP协议 映射IP-MAC
	3.IP网际协议说明IP数据报的格式
	3.IP数据报首部有协议、源、目标地址 协议指出数据应交给哪个进程 ICMP|IGMP|OSPF TCP|UDP
	4.路由器 分组转发
	5.解决ip地址耗尽：CIDR、NAT地址转换、IPv6
	6.ICMP网际控制报文协议 在主机之间发送报文差错控制信息(不解决)
	7.路由选择协议-内部网管-RIP路由信息选择协议(跳数，邻居告知)
		       	       -OSPF开放式最短路径优先协议(广播连接关系、网络拓扑图、Dijkstra算法)
五、传输层
	1、运输层为应用进程间提供端到端的逻辑通信(网络层提供主机之间),还要对收到的报文提供差错检验，TCP|UDP
	2、TCP协议提供可靠的，面向连接的(套接字连接)，字节流服务
	3、可靠：停止等待协议(发送完分组等待确认)、
		    连续ARQ协议(连续发送分组，确认按序到达的最后一个)、
		    滑动窗口协议(控制发送方发送窗口大小，进行流量控制，防止数据丢失)
	4 流量控制： 滑动窗口协议控制
	  拥塞控制： 慢开始(1-加倍)和拥塞避免(达到阈值，增加1) 没有按时收到确认,认为拥塞 阈值设为顶峰一半，重新开始
	  		   快重传 收到失序报文发送重复确认，连续收到三个重复确认
	  		   快恢复 慢开始阈值设为一半，从阈值开始执行拥塞避免
	5、发送窗口 为拥塞窗口，接收方窗口的最小值
	6、TCP连接
		三次握手：保证双方都准备好进行数据传输、双方确认初始序列号
		四次挥手：
		2MSL：为了最后一次确认能够到达服务端、同时确保本次连接的报文都能够失效
		RST复位包：发送关闭，不等回复自己就关闭
	7、UDP 代价低、场景需要 提供无连接、不可靠的数据报服务

	8、UDP: 无连接 不可靠 面向报文   一对一一对多多对多  首部小
	   TCP:  连接   可靠  面向字节流 一对一           首部开销大 有拥塞控制和流量控制

六、应用层
	1、每个应用层协议都是为了解决某一类问题
	2、DNS域名解析 递归本地 迭代根、顶级、权限  域名服务器同步时TCP域名解析时用UDP
	3、FTP 控制端口21 传输端口20 TCP
	4、WWW HTTP(TCP)
	5、邮件 发送SMTP 接受POP3|IMAP 与邮件服务器间通过HTTP

七、其他
	1、网络层安全协议 VPN IP数据报->加首尾控制信息+新首部成为安全数据报 
	2、传输层安全协议 SSL->TLS 建立TCP连接之后
	3、SSL/TLS建立过程
		->A支持的加密算法
		<-B选定的加密算法
		<-B的包含RSA公钥的证书
		A用CA的公钥解密该证书，得到RSA公钥
		->A生成随机数，加密传给B
		双方根据随机数+算法生成对称会话秘钥
		<-B发送确认
		安全传输

HTTP:
	1、定义：HTTP是一个在计算机世界里专门在「两点」之间「传输」「超文本」数据的「约定和规范」
	2、常见状态码：
		200：成功
		3xx：重定向
			301:永久重定向，用新的url访问
			302:临时重定向
		4xx:客户端报文有误
			400:笼统的错误
			403:服务器禁止访问，无权限
			404:请求资源未找到
		5xx:服务器异常
			500:笼统错误
			502:通常是网官和防火墙导致访问不了，后端正常
			503:服务器很忙，暂时无法处理请求
	3、GET POST
		get delete put请求数据、幂等 post提交非安全非幂等
	4、HTTP(1.1)的优缺点
		优点：
			简单：header+body都是k-v
			灵活和易于扩展:字段未定死，同时在应用层，下层可以随意更改
			应用广泛和跨平台
		缺点：
			无状态
			明文传输
			不安全(不加密，不验证身份，不验证完整性)https
	
	5、HTTP/HTTPS(混合加密+摘要算法+数字证书)

	6、  HTTP 1.0
		HTTP 1.1 长连接+管道网络传输(连续发送多可请求) 队头阻塞问题
		HTTP 2 头部压缩+二进制格式+(无顺序请求)多路复用+服务器推送 基于https tcp丢包问题
		http 3 udp+quic 不管顺序也不管丢包

WebSocket
	建立在tcp上
	采用http完成一部分握手操作
	有状态、服务器主动请求


=================================================
				===并发===
=================================================

一、并发编程的挑战
	1、上下文切换 (无锁并发编程(避免锁竞争)，CAS算法，使用最少线程，协程)
	2、死锁
		条件：1、互斥条件 2、不可剥夺条件 3、请求与保持条件 4、循环等待条件
		解决：1避免同时获得多个锁 2避免一个锁内使用多个资源 3尝试使用定时锁 4数据库锁加锁和解锁在一个链接里
		Java：按序加锁、加锁时限、死锁检测(维护一个数据结构)
	3、资源限制(硬件(上传下载 读写)(集群) 软件(连接数)(池化复用)）
二、Java并发机制的底层实现
	1、volatile ①Lock前缀指令会引起处理器缓存写会主内存 ②处理器缓存写会主内存会使其他处理器的缓存失效
	2、synchronized 1.6后优化:获取对象的monitor监视器
		无锁： 偏向锁标识为0，则CAS获取偏向锁
		偏向锁：偏向锁标识为1，锁对象记录线程ID，下次该线程获取时直接测试，失败则CAS尝试锁记录指向当前线程ID
				失败则自旋，等到自旋超过一定时间或次数，升级为轻量级锁
		轻量级锁：加锁：当前线程的栈帧中创建空间，CAS将对象头的MarkWord复制该空间，尝试对象图的MW指向该空间
						成功则获得锁，失败则自旋
				 解锁：CAS操作将栈帧中的锁记录Displaced MarkWoed替换回对象头，
				       成功即解锁，失败则有竞争，膨胀为重量级锁，阻塞竞争线程，自己释放锁并唤醒竞争线程

		重量级锁：竞争线程阻塞，解锁后唤醒竞争线程
	3、原子操作
		1、锁(CAS方式释放获取锁)
		2、自旋CAS(ABA(版本号)、循环开销、只保证一个共享变量的原子操作)

三、Java内存模型
	1、Java并发采用共享内存模式(消息传递模式)隐式通信显示同步
	2、主内存存储共享变量  每个线程有本地内存保存主内存的共享变量副本
四、Java并发基础
	1、进程资源分配的最小单位、线程程序执行的最小单位
	2、线程的状态 
	 new->runnable(running、ready)->terminated waiting|time_waiting|blocked
	3、中断线程interrupt 而不使用stop(不释放资源)；也可在线程内部使用一个boolean变量 
	4、线程先获取监视器对象，获取失败则进入SynchronizedQueue wait->进入WaitQueue->notify->SynchronizedQueue
？	|5、t.join 当前线程进入wating态等待t线程执行完 涉及等待通知机制 给t加锁 让当前线程等待，t结束时唤醒当前线程
	6、ThreadLocal线程本地变量 数据库连接管理保证当前线程操作的Connection都为同一个
	  ThreadLocal.set会在thread中ThreadLocalMap保存值，以ThreadLocal为键，value为值
	  ThreadLocal.get会获取thread中的ThreadLocalMap以ThreadLocal取值
	  ThreadLocalMap是ThreadLocal的内部类，被thread引用
五、Java中的锁
	1、Lock接口 非阻塞获取锁、超时获取锁、响应中断的获取锁
	2、AQS
		1定义同步组件，实现AQS，重写相应方法，同步组件调用AQS的模板方法即可
		2依赖同步队列完成同步状态的管理 同步队列中有节点保存获取同步线程失败的线程引用，等待状态 
		 同步器包含头尾节点，首节点是获取同步状态成功的节点，释放同步状态时唤醒后继节点并设置为首节点

	3、重入锁：重复加锁而不被自己阻塞 ReentrantLock|Synchronized
	 公平与非公平锁：是否请求顺序 ReentrantLock 
	4、读写锁ReentrantReadWriteLock 一个读多个写 维护一对读锁写锁 同步整型状态按位切割 锁降级(写->读)
	5、LockSupport工具 阻塞唤醒当前线程
	6、Condition(Lock.newCondition) 类似wait/notify 作为同步器的内部类，AQS引用多个Condition等待队列
	  await同步队列首节点->等待队列尾结点 signal等待队列首节点->同步队列首节点
六、Java并发容器和框架
	1、ConcurrentHashMap 
	 JDK7 segment[](继承自ReentantLockd)->数组+链表 get不加锁(volatile修饰) put加分段锁(判断是否扩容，单个Segment扩容)
	 JDK8 数组+链表+红黑树 get不加锁 put时初始化，没有hash冲突直接CAS插入，有就synchronized锁住头结点插入
	 	put操作
	 		1数组为空则进行初始化
	 		2首节点为空则cas直接插入
	 		3需要扩容则协助扩容
	 			扩容时多线程并发扩容helpTransfer 特殊首节点ForwardingNode表示已扩容过直接跳过
	 		4首节点加synchronized锁put
	2、线程安全队列 非阻塞(循环cas)|阻塞(锁)
	3、ConcurrentLinkedQueue无界线程安全队列 cas入队尾结点 cas出队列头结点
	4、阻塞队列BlockingQueue
		ArrayBlockingQueue 数组结构的有界阻塞队列(必须指定长度) 不保证公平访问
		LinkedBlockingQueue 链表结构的有界阻塞队列(可指定，默认长度为int_max) 
		PriorityBlockingQueue 支持优先级的无界阻塞队列(可扩容，长度最大也为int_max(queue为数组实现的堆))
		DelayQueue 延时获取元素的无界阻塞队列
		SynchronnousQueue 一个put对应一个take不存储元素
		LinkedTransferQueue 链表结构的无界阻塞队列
		LinkedBlockingQueue 链表结构组成的双向阻塞队列

		阻塞队列实现原理 等待通知模式 condition.await|signal->LockSupport.park|unpark(先保存当前线程再阻塞)->底层park|unpark
七、原子操作类
	原子更新基本类型 AtomicBoolean AtomicInteger AtomicLong(其他基本类型 转为int型)
	 以AtomicInteger的getAndIncrement为例
	 	get()获取旧值 新值=旧值+1
	 	cas(旧值,新值)->unsafe的native方法
	 	循环直到成功
	原子更新数组 AtomicIntegerArray AtomicLongArray AtomicReferenceArray
	原子更新引用类型 AtomicReference AtomicReferenceFiledUpdatr AtomicMarkableReference
	原子更新字段类 AtomicIntegerFiledUpdater AtomicLongFiledUpdater AtomicStampedReference
八、Java中的并发工具类
	1、CountDownLatch替代join实现计数器
	2、CyclicBarrier 阻塞一批线程直到所有线程都完成，打开屏障
	 下一步动作实施者不一样CountdownLatch为主线程 CyclicBarrier为其他线程
	 CyclicBarrier 计数器可以重置 适合更复杂场景
	3、Semaphore 控制并发线程的数量 流控
	4、Exchanger 线程间交换数据
九、线程池
	1、实现原理
		execute提交任务
		核心线程池未满(即使有空闲，不销毁)则创建线程执行任务，已满则阻塞队列是否已满，未满则加入队列，已满则看线程池是否已满，未满则创建线程执行任务，已满则执行拒绝策略

		创建的线程封装为工作线程Worker,执行完从阻塞队列中获取任务
	2、new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory,handler)
		corePoolSize 核心线程大小
		maximumPoolSize 最大线程数量
		keepAliveTime 空闲线程存活时间
		workQueue
			ArrayBlockingQueue
			LinkedBlockingQuene
			SynchronousQuene
			PriorityBlockingQueue
		threadFactory 线程工厂 主要定义名字
		handler 拒绝策略
			AbortPolicy 直接丢弃 抛出RejectedExecutionException异常
			DiscardPolicy 直接丢弃
			DiscardOldestPolicy 抛弃最早进入队列的任务，放进队列
			CallerRunsPolicy 调用者线程执行


	3、Executor框架
		ThreadPoolExecutor
			SingleThreadExecutor 1-1 LinkedBlockingQueue
			FixedThreadPool core-max LinkedBlockingQueue
			CacheThreadPool 0-max SynchronousQueue 不同创建线程
		ScheduledThreadPoolExecutor 比Timer更灵活
			ScheduledThreadPoolExecutor
				DelayQueue 内部是一个PriorityQueue把time小的优先 任务需要实现Delay接口
			SingleThreadScheduledExecutor
		Future 表示结果
		Runnable
		Callable
		Executors
=================================================
				===JVM===
=================================================

二、Java内存区域与内存溢出异常
	1、运行时数据区
	  线程私有：
		1.程序计数器 行号指示器(程序控制流、线程恢复)
		2.Java虚拟机栈 方法对应栈帧,主要是局部变量表(基本类型、对象引用、返回地址)、操作数栈、动态链接、方法出口
					Hotspot无法扩展，不会OOM，只会StackOverflowError
		3.本地方法栈 Hotspot中与虚拟机栈合二为一
	   线程共享：
		4.Java堆 存储对象实例(对象中的基本类型也在堆),在堆上存在TLAB(线程私有的分配缓冲区)提高分配效率
			   内存不足会OOM
			   逃逸分析(栈上分配、标量替换)在栈上分配对象内存  
		5.方法区 在本地内存实现元空间，(类型信息)、
		6.(常量、静态变量、JIT后的代码缓存)->都移到堆中
		 运行时常量池(属于方法区) class文件的常量池表(编译期的字面量和符号引用)，运行期也可动态加入
		  字符串常量池在堆中
		7.本地内存 nio时堆中有DirectByteBuffer对象指向并引用本地内存
	2、HotSpot虚拟机对象揭秘(以堆为例)
		1.对象的创建
			new 对象 先把类加载到内存中->堆上分配内存->初始化实例变量0值->对象头信息设置-><init>实例构造器(实例赋值、构造函数)
		2.对象的内存布局
			对象头  ①对象自身的运行时数据(gc/hash/锁) ②类型指针(哪个class的实例)
			实例信息
			对其填充
		3.对象的访问定位
			句柄访问     栈->指向句柄池(指向堆中的对象实例|指向方法区中的类型数据)
			直接指针访问 栈->堆中对象实例(对象实例中对象头->方法区)

三、垃圾收集器与内存分配策略
	1、对象是否存活
		1引用计数法
		2可达性分析算法(该对象与GC Roots根对象是否可达)
			GC Roots
				1虚拟机栈局部变量表中引用的对象
				2本地方法栈中引用的对象
				3堆区静态属性引用的对象
				4堆区静态常量引用的对象
				5Java虚拟机内部的引用(基本类型的Class对象，常驻异常对象)
				6同步锁持有的对象
				7反映JMXBean、JVMTI中注册的回调、本地代码缓存等
				根据所选垃圾收集器和内存区域不同，有动态加入

		3引用分类
			强引用 不会被gc
			软引用 第一次gc不会回收，内存还不够纳入第二次gc回收范围
			弱引用 会被回收
			虚引用 不影响gc，也无法通过其得到对象实例，只是为了被gc时得到一个通知
		4生存还是死亡(一般不重写finalize())
			无GC Roots引用，先标记，是否有必要执行finalize()方法，
				无必要(没有重写，已执行过),回收
				有必要，执行finalize()，重新引用上即可不被GC
		5方法区回收(不再使用的类型(所有实例被回收、其类加载器已被回收,Class对象没被引用))
			在大量使用反射、动态代理、CGLib等框架需要具备类型卸载能力(即方法区回收)
	2、垃圾收集算法
		1.分代收集理论(绝大多数对象朝生夕灭，熬过多次的对象难消亡，跨代引用占少数)
		2.标记-清除算法(标记清除两个过程随着对象数量增多效率降低，内存碎片化)
		3.标记-复制算法(解决标记清除效率低，内存碎片，但是浪费空间 8:1:1)
		4.标记-整理算法(标记完不可回收对象，将其移动到一变，清除另一边)
	3、经典的垃圾收集器
		ParNew收集器 多线程标记复制
		CMS基于标记-清除算法(长停顿过程可以与用户线程并发，减少停顿，加快响应)
			初始标记-标记GC Roots能直接关联的对象
			并发标记-从直接关联对象遍历整个对象图
			重新标记-修正并发表近的变动
			并发清除-清除
			产生的碎片会在不得不进行full GC时进行碎片整理
		G1 把对空间划分为Region区域，每个Region区可以扮演新生代，老年代，采取不同算法 优先处理回收价值收益大的Region
			初始标记 找GC Roots直接关联对象
			并发标记 并发扫描
			最终标记 修正
			筛选回收 更新Region统计数据，对回收价值和成本排序，存活对象复制到新Region，清理掉就Region
	4、内存分配与回收策略
		对象优先在Eden区分配
		大对象直接进入老年代
		长期存活的对象将进入老年代
		动态对象年龄判定 同龄对象超过survivor一半直接进入老年代
		空间分配担保 survivor无法容纳的对象送进老年代



七、虚拟机类加载机制p357
	1、类的加载时机
		有且仅有主动引用的时候(通过子类引用父类静态变量，子类不初始化|数组定义的类不初始化|final常量存在于调用类)
			1new、读取或设置静态字段(final修饰的已在常量池的除外)、静态方法
			2对类型反射调用
			3main方法所在类
			4初始化子类时先初始化父类
			5有默认方法的接口的实现类初始化时，先初始化接口
			6动态语言 MethodHandle实例的方法句柄对应的类
	2、类加载的过程
		加载、连接(验证、准备、解析)、初始化
			加载(1全限定名找字节流，2字节流静态->方法区运行时数据结构 3在方法区生成class对象)
			连接
				验证：验证字节流的是否合法
				准备：静态变量并赋0值(常量直接赋值)
				解析：常量池内的符号引用转化为直接引用
			初始化 执行类构造器(类变量赋值、执行static代码块)
	3、类加载器(实现通过全限定名获取该类的二进制字节流)
		1类加载器+类本身确定唯一性
		2双亲委派模型
			启动类加载器<-扩展类加载器<-应用程序类加载器(ClassLoader.getSystemClassLoader)<-自定义类加载器
			一个类加载器收到类加载请求，把请求委派给父类加载器去完成，父类加载器无法加载时自己才去尝试加载。
		3破坏双亲委派模型
			1自定义类加载器，重写loadClass方法(这个方法实现了双亲委派)
			2JNDI接口由启动类加载器加载，实现由它(一般是应用程序类加载器)加载，使用线程上下文类加载器，实现由父类请求子类的行为
			3模块化热部署 模块有自己的类加载器，会调用平级模块的类加载器

=================================================
				===MySQL===
=================================================
一、MySQL
	1.查询过程
		客户端->查询缓存->语法解析->查询优化->查询执行引擎->存储引擎 
	2.InnoDB结构
		后台线程：Master(将缓冲池数据异步刷新到磁盘(合并插入缓冲))、IO(AIO处理读写请求)、Purge(回收undo页)、Page Cleaner(脏页刷新)
		存储引擎内存池：缓冲池(数据页，索引页，插入缓冲，自适应哈希索引，锁信息)、重做日志缓冲(master/s,事务提交，剩余空间小于1/2)、额外内存池
		磁盘文件：
	3.InnoDB关键特性
		行锁设计、支持非锁定读，MVCC多版本高并发控制、实现4中隔离级别、next-key locking解决幻读、自适应哈希索引(自动为索引上的热点页建立)
	4.文件
		参数文件(初始化my.cnf)
		日志文件(错误日志、慢查询文件、查询日志、进制日志binlog【记录对MySQL执行更改的所有操作(sql形式)】逻辑日志-(恢复(完全备份后+binlog恢复)、复制(主从之间)、审计(检查是否有注入攻击)
											格式：statement(sql语句)、row(行更改情况，更大存储空间)、mixed
		套接字文件
		pid文件
		表结构定义文件
		InnoDB存储引擎文件
			表空间文件(主要放在共享表空间)
			重做日志文件(redo、事务日志、每个页的物理更改)
	5.InnoDB表
		1.索引组织表，都是按主键顺序存储(无主键则从非空唯一索引(unique not null)、生成6字节主键)
		2.InnoDB逻辑存储结构
			表空间(共享、独立表空间)-段(数据段、索引段)-区(1MB 一个区64个页)-页(16k 数据页、索引页、插入缓存位图页、undo页)-行记录(Compact、Redundant两种格式)

二、索引与算法(InnoDB支持 B+树索引、自适应哈希索引、全文索引)
	B+树索引
		1.聚集索引：按主键构建B+树，叶子节点存整个数据页的行记录，数据页通过双向链表连接
		2.辅助索引：按指定列构建B+树，叶子结点存键值+bookmark书签(告诉主键值去聚集索引找)
		Candinality预估建索引是否有高选择性，可取范围大
		
		where a=xxx查询类更易走索引
		联合索引 满足最左匹配原则
		覆盖索引 在辅助索引中可以直接拿到数据
		索引提示 use index/force index

		MRR(Multi-Range Read)优化：从辅助索引得到的键值根据rowid排序去访问 减少缓冲池页的替换次数，查询效率更高
		ICP优化(索引下推):从辅助索引的取出条件的同时对条件进行过滤(辅助索引要能覆盖到)，更快
	哈希索引
		字典类查找特别快 where a=xxx 范围查找无能为力
	倒排索引
		全文检索
三、锁 (隔离性)
	1、
	latch(闩锁：mutex互斥量和rwlock读写锁 保证并发进程操作临界资源的正确性，没有死锁检测机制)
		对象是线程，保护内存数据结构，持续在访问临界资源过程
	lock(保证隔离性 行锁，表锁，意向锁)
		对象是事务，保护数据库内容(表，页，行)，持续在整个事务过程

		行级锁：(通过事务访问的页对行级锁进行管理，采用位图法，一个页多个行级锁 开销不大)
			共享锁(S锁)：允许事务读一行数据
			排它锁(X锁)：允许事务删除或更新一行数据
		意向锁(表级别)：主要揭示事务在下一行被请求锁的类型
			意向共享锁(IS锁)：事务想要获取表中某几行的共享锁
			意向排它锁(IX锁)：事务想要获取表中某几行的排它锁
		通过意向锁，实现多粒度锁定，先对表表上锁再对行记录上锁

	2、一致性非锁定读(解决不可重复读)
		MVCC：一个行记录可能有多个版本快照数据，由此带来的并发控制
		通过MVCC，读取操作不会等待X行锁的释放，去读取行记录的之前版本的快照数据(通过undo实现)
		read commited:读最新一份快照数据
		repeatable read:读事务开始前的一份数据
	3、一致性锁定读
		select ... for update X锁
		select ... lock in share mode S锁
	4、自增长与锁
		select max(auto_inc_col) from t for update
		插入操作相当于加了一个X锁，获取自增长计数器+1，但是比较特殊，插入SQL语句执行完后就释放
			确定行数插入-互斥量mutex
			不确定行数插入-加X锁
	5、行锁的3种算法
		record lock:单个记录上的锁
		gap lock :锁定一个范围，但不包含记录本身
		next-key lock:锁定一个范围，锁定记录本身
	6、next-key locking 解决幻读
		where x>2 锁定[2,-)范围，这个范围类的插入都被阻塞
	7、锁问题
		脏读、不可重复读、幻读
		读未提交、读已提交、可重复读、串行化
	8、死锁
		解决 超时机制:超时回滚，大的undo操作会开销更大
	（innod) 死锁检测:采用等待图(构建一个锁和事务等待的图，是否有回路)，选择回滚undo量最小的事务进行回滚
	9、隔离技术
		mvcc(undo:两个隐藏列，一个修改事务id，一个回滚指针指向回滚段的unlog记录) 快照读
		next-key-lock(行锁+间隙锁) 当前读(一致性锁定读+d+u+i)

四、事务(扁平事务、带有保存点的扁平事务、链事务、分布式事务)
	1、原子性、持久性 一致性 通过redo undo实现 
	2、持久性 redo log
		-> redo日志缓冲 -> 磁盘文件(重做日志文件)  恢复比binlog块
		事务提交|master线程per/s|redolog缓冲池小于1/2 时刷新redo缓冲
	3、一致性 undo log
		回滚：逻辑的将数据库回滚到恢复到原来的样子(redo逆操作)
		MVCC：通过undo实现

		undo log的产生也会产生redo log,也需要持久性的保护


五、备份与复制
	冷备：复制相关文件即可，简单，恢复速度快，不需要重建索引，数据库不可用
	热备：①记录备份开始redolog日志序列号
		 ②复制相应的表空间文件 
		 ③记录备份完redolog日志序列号 
		 ④复制在备份期间产生的redolog文件
	复制(完全备份+二进制还原)
		1主服务器把数据更改记录到binlog中
		2从服务器把binlog复制到自己的中继日志中
		3服务器重做中继日志中的日志，把更改应用到自己的库上
六、分布式事务
	2pc两阶段提交:投票阶段+
	tcc补偿事务：
	MQ消息队列：最终一致性


=================================================
				===Redis===
=================================================
1、redis应用场景
    redis 五种数据类型使用场景！
    String：短信验证码，存储一个变量
    hash：json 字符串{对象转换的字符串}
        hset(key,field,value);
        hset(key,id,1);
        hset(key,name,admin);
        hget(key,field)
    // update bean

    list：lpush ，pop 队列使用
    set：去重，交集，并集，补集。。。 不重复！
    zset：评分，排序
1.2 数据结构底层(dict)
    hash 底层 dict字典结构
        两个hashtable渐进式扩容
        元素个数=hash表长度时 2倍扩容
        元素个数=hash 1/10   缩容
    zset
        ziplist(个数<128,字节<64)
        skiplist zset(dict(member socre) skiplist) 多层链表logn

2、
    缓存击穿
        缓存中的某一个key，失效了。此时会导致大量用户访问数据库。会造成缓存的击穿！
        加锁：
            分布式锁：
            redis 	setnx，setex
                    set(key,value,nx,px,timeout)
                    set k1 v1 px 10000 nx

                    使用k1 当作锁！

             redisson ： 工具
								
    缓存雪崩
        缓存中的所有key全部失效！此时会给数据库造成压力！
        解决方案：
            将缓存中的key 设置的过期时间不一致，不同！

    缓存穿透
        用户查询一个在数据库中根本不存在的数据，此时会造成穿透！

3、过期键的删除策略
    定时删除： 在设置键的过期时间的同时，创建一个定时器，让定时器执行对键的删除操作
    惰性删除： 每次取的时候先判断 expires 对象里面的键是否已经过期，如果过期，则删除键，否则，返回该键
    定期删除： 每隔一段时间，程序对数据库遍历检查一遍，然后删除过期的键
4、内存淘汰策略
    设置过期时间的数据集中挑选
        volatile-lru:
        volatile-ttl:
        volatile-random:
    从所有
        allkeys-lru:
        allkeys-random:
    禁止驱逐数据，可读不可写，默认
        no-enviction:
5、分片：划分数据
	客户端分片：客户端一致性哈希 解决冗灾和扩容；虚拟节点(对节点产生多个hash)
	代理分片：代理分片
	服务器分片：Redis Cluster
6、redis为什么快
    1基于内存，读取很快
    2单线程，减少上下文切换和资源竞争，保证每个操作的原子性
    3IO多路复用，单线程轮询描述符，处理多个socket连接
    4dict数据结构，访问很快(zipset,skiplist等数据结构)
7、DB和缓存一致性解决方案
	1先淘汰缓存、再写DB  利用分布式锁实现串行读写解决并行读写(可以设置缓存过期时间实现双删策略)
	2先写DB、再更新缓存  利用分布式事务保证最终一致性(可以版本号解决先后次序)
	3利用MySQL的binlog  实现异步更新缓存



=================================================
				===DS===
=================================================
单例模式：保证只有一个实例
生产者消费者：生产者生产到缓冲区，消费者从缓冲区拿数据，缓冲区多是阻塞队列，解耦，支持并发
观察者模式：定义对象间一种一对多的依赖关系，使得一个对象状态改变时，与之相关的对象也要随之做出相应的变化 Subjet(subjectImpl)----notify--->Observer(observerImpl)
			观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理
			观察者较多容易性能低，同时容易出现循环引用造成假死
策略模式：Context(传入strategy内部执行)->IStrategy(相同逻辑)->strategyImpl(具体实现)
模板方法模式：由一个抽象类和一组实现组成，抽象类定义一个操作中算法的框架，而将一些步骤延迟到子类实现

工厂模式：降低耦合度
	静态工厂：没有工厂接口
	工厂方法：一个工厂生产一种产品(一个产品接口的实现) 工厂接口 工厂实现 产品实现 产品接口
			定义一个用于创建对象的工厂接口，让子类决定实例化哪一个类
	抽象工厂：一个工厂生产一个产品族
			新增产品时，要改动抽象工厂



=================================================
				===Docker===
=================================================
1、Docker:一次封装，到处运行，解决了运行时环境和容器配置问题
2、三大要素：镜像，容器(简易版linux+应用)，仓库
3、底层原理：CS架构，Docker守护进程运行在服务器，接受客户端的命令管理运行容器
4、比VM快：1有比VM更少的抽象层，不用实现硬件资源虚拟化 2利用宿主机的内核
5、Docker镜像：
	联合文件系统：支持对文件系统的修改作为一次提交来一层层叠加
	DockerFile：构建Docker镜像的构建文件
	Docker镜像加载原理：先加载bootfs(bootloader+kernel),加载完内核后会卸掉，然后加载rootfs(包括linux标准文件和目录)，在加载其他
	分层镜像：每一层只需要拉取一次，每一层只需要加载一次，每一层可以被共享
6、Docker容器数据卷：由docker挂载到容器
	类似于rdb和aof，持久化容器数据，容器间继承和共享数据
	数据卷容器：挂载数据卷的容器，容器间数据共享


=================================================
				===其他===
=================================================


1、第一阶段：网络数据到达内核缓冲区准备好数据  第二阶段：内核缓冲区复制到应用程序
  阻塞式BIO： IO线程到内核缓冲区请求数据，未准备好则阻塞进程
  非阻塞式NIO： IO线程到内核缓冲区请求数据，未准备好则轮询
  IO多路复用：IO事件注册到 select/poll/epoll
  				select/poll 每次把全部描述符复制到内核，遍历文件描述符是否就绪
  				epoll epoll_ctl把就绪的文件描述符注册时已经复制到内核、准备好的文件描述符会加入就绪队列中，epoll_wait可以获取就绪队列中的文件描述符

  				select 微妙实时性，只1024个连接
  				poll   毫秒，连接无限制
  				epoll  大于1000连接，且长连接有必要
  信号驱动IO：发信息号可以进行第二阶段了
  异步IO：发信号已完成
2、进程直接的通信方式 管道通信(单向)、消息队列、共享内存 | 信号量(资源计数)、套接字(socket不同设备)
  线程 同步机制(锁、volatile)、通知等待机制、管道输入输出流
  进程线程的区别:
    1.进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位
    2.同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源相互独立。
3、海量数据 hash、位图、布隆过滤器
5、tcp状closed listen syn_sent syn_rcvd established
6、第四次握手发送后A-B A进入time_wait 确保最后一个确认报文能到达|让本连接产生的所有报文失效 
                 A断开了，B没断开，B再给发确认 A收到后发送rst复位包
7、索引创建：选择性高低、字段短、where条件中常出现、不经常增删的表、表数据量的适合建索引
8、threadlocal 内存泄漏，线程-threadlocalmap-entry(用完要把remove 把entry对象删除，而不仅仅是把key-null)
9、拷贝分为引用拷贝和对象拷贝,对象拷贝又分为浅拷贝和深拷贝
10、悲观锁(加锁实现) 乐观锁(版本号实现 在数据进行提交的时候检测冲突，冲突则回滚)